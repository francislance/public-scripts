#!/usr/bin/env bash

# Trim Helm history based on the SUMMARY output of check-helm.sh.
#
# Usage:
#   ./trim-helm-history-from-report.sh [--file=FILE] [--confirm=yes|no]
#
# Defaults:
#   FILE          = helm-releases-summary.txt
#   --confirm     = yes  (ask per release)
#
# Requirements:
#   - bash (3.x+)
#   - helm
#   - kubectl
#   - jq

set -u

CONFIRM="yes"                         # default behavior
SOURCE_FILE="helm-releases-summary.txt"  # default file

# ---------- Parse arguments ----------
for arg in "$@"; do
  case "$arg" in
    --file=*)
      SOURCE_FILE="${arg#*=}"
      ;;
    --confirm=*)
      CONFIRM="${arg#*=}"
      ;;
    -h|--help)
      echo "Usage: $0 [--file=FILE] [--confirm=yes|no]"
      echo
      echo "  --file=FILE       Summary file generated by check-helm.sh"
      echo "                    (default: helm-releases-summary.txt)"
      echo "  --confirm=yes     Ask per release before deleting (default)"
      echo "  --confirm=no      Delete without per-release confirmation"
      exit 0
      ;;
    *)
      echo "ERROR: Unknown argument: $arg" >&2
      echo "Use --help for usage." >&2
      exit 1
      ;;
  esac
done

if [[ ! -f "${SOURCE_FILE}" ]]; then
  echo "ERROR: File not found: ${SOURCE_FILE}" >&2
  echo "       Make sure you ran check-helm.sh first, or specify --file=..." >&2
  exit 1
fi

if [[ "${CONFIRM}" != "yes" && "${CONFIRM}" != "no" ]]; then
  echo "ERROR: --confirm must be 'yes' or 'no' (default is 'yes')." >&2
  exit 1
fi

# ---------- Verify file was generated by check-helm.sh ----------
if ! grep -q "Report generated through script - check-helm.sh" "${SOURCE_FILE}"; then
  echo "ERROR: Input file does NOT appear to be generated by check-helm.sh." >&2
  echo "       Missing marker line: 'Report generated through script - check-helm.sh'" >&2
  echo "       Aborting to avoid using manually prepared / incorrect input." >&2
  exit 1
fi

# ---------- Tool checks ----------
if ! command -v helm >/dev/null 2>&1; then
  echo "ERROR: 'helm' command not found in PATH." >&2
  exit 1
fi

if ! command -v kubectl >/dev/null 2>&1; then
  echo "ERROR: 'kubectl' command not found in PATH." >&2
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: 'jq' command not found in PATH." >&2
  exit 1
fi

echo ">>> Using input file: ${SOURCE_FILE}"
echo ">>> CONFIRM = ${CONFIRM} (yes = ask per release, no = non-interactive)"
echo

FOUND_LINES=0

# Function to output summary lines as: namespace|release|revisions
summary_stream() {
  awk '
    /NAMESPACE[[:space:]]+RELEASE[[:space:]]+REVISIONS/ {start=1; getline; next}
    start==1 && NF>=3 && $1 != "NAMESPACE" && $1 !~ /^-+$/ {
      # $1 = namespace, $2 = release, $3 = revisions
      print $1 "|" $2 "|" $3
    }
  ' "$1"
}

# ---------- Main loop over summary rows ----------
while IFS='|' read -r NAMESPACE RELEASE_NAME REV_COUNT_REPORTED; do
  FOUND_LINES=1

  echo "============================================================"
  echo "Processing release '${RELEASE_NAME}' in namespace '${NAMESPACE}'"
  echo "Reported revisions (from check-helm.sh): ${REV_COUNT_REPORTED}"
  echo "============================================================"

  # Get current helm history in JSON
  HISTORY_JSON="$(helm history "${RELEASE_NAME}" -n "${NAMESPACE}" -o json 2>/dev/null || true)"

  if [[ -z "${HISTORY_JSON}" ]]; then
    echo "  [WARN] Unable to retrieve helm history for ${RELEASE_NAME} in ${NAMESPACE}."
    echo "         It may have been deleted or there was an error."
    echo
    continue
  fi

  COUNT="$(echo "${HISTORY_JSON}" | jq 'length')"
  echo "  Actual current revision count: ${COUNT}"

  if [[ "${COUNT}" -le 3 ]]; then
    echo "  Info: Only ${COUNT} revision(s) present (<= 3). Nothing to delete."
    echo
    continue
  fi

  # Extract revision numbers and sort ascending
  ALL_REVS="$(echo "${HISTORY_JSON}" | jq '.[].revision' | sort -n)"
  NUM_TO_DELETE=$(( COUNT - 3 ))

  REVS_TO_DELETE_STR="$(echo "${ALL_REVS}" | head -n "${NUM_TO_DELETE}")"
  REVS_TO_KEEP_STR="$(echo "${ALL_REVS}" | tail -n 3)"

  echo "  Revisions to keep (latest 3):"
  echo "    ${REVS_TO_KEEP_STR}"
  echo "  Revisions to delete (oldest ${NUM_TO_DELETE}):"
  echo "    ${REVS_TO_DELETE_STR}"
  echo

  # Build list of secrets to be deleted
  SECRETS_LIST=""
  while read -r REV; do
    [[ -z "${REV}" ]] && continue
    SECRET_NAME="sh.helm.release.v1.${RELEASE_NAME}.v${REV}"
    SECRETS_LIST="${SECRETS_LIST}- ${SECRET_NAME}, namespace ${NAMESPACE}\n"
  done <<< "${REVS_TO_DELETE_STR}"

  if [[ -z "${SECRETS_LIST}" ]]; then
    echo "  [WARN] Computed no secrets to delete for this release. Skipping."
    echo
    continue
  fi

  DO_DELETE="yes"

  if [[ "${CONFIRM}" == "yes" ]]; then
    echo "Secrets to be deleted for release '${RELEASE_NAME}' in namespace '${NAMESPACE}':"
    printf "%b" "${SECRETS_LIST}"
    echo

    # Ask user whether to proceed for this release, reading from the terminal, not stdin
    while true; do
      printf "Proceed to delete these secrets? [yes/no]: " > /dev/tty
      if ! read -r ANSWER < /dev/tty; then
        ANSWER=""
      fi

      case "${ANSWER}" in
        yes|y|Y)
          DO_DELETE="yes"
          break
          ;;
        no|n|N)
          DO_DELETE="no"
          break
          ;;
        *)
          echo "Please answer 'yes' or 'no'." >&2
          ;;
      esac
    done
  else
    echo "  Non-interactive mode (--confirm=no): will delete secrets without prompt."
    echo
  fi

  if [[ "${DO_DELETE}" != "yes" ]]; then
    echo "  Skipping deletion for release '${RELEASE_NAME}' in namespace '${NAMESPACE}'."
    echo
    continue
  fi

  # Perform deletions
  while read -r REV; do
    [[ -z "${REV}" ]] && continue
    SECRET_NAME="sh.helm.release.v1.${RELEASE_NAME}.v${REV}"

    echo "  Deleting secret '${SECRET_NAME}' in namespace '${NAMESPACE}'..."
    if kubectl delete secret "${SECRET_NAME}" -n "${NAMESPACE}" --ignore-not-found; then
      echo "    OK: Deleted ${SECRET_NAME}"
    else
      echo "    ERROR: Failed to delete ${SECRET_NAME}" >&2
    fi
  done <<< "${REVS_TO_DELETE_STR}"

  echo

done < <(summary_stream "${SOURCE_FILE}")

if [[ "${FOUND_LINES}" -eq 0 ]]; then
  echo "No releases found in summary table (nothing to trim)."
fi

echo "All done."
