#!/usr/bin/env bash

# Trim Helm history based on the SUMMARY output of check-helm.sh.
#
# Usage:
#   ./trim-helm-history-from-report.sh [--file=FILE] [--confirm=yes|no] [--failed-only]
#
# Defaults:
#   FILE          = helm-releases-summary.txt
#   --confirm     = yes  (ask per release)
#
# Modes:
#   - Default: Read "History limit: X" from the summary file header.
#              For each release, keep the latest X revisions, delete older ones
#              by deleting sh.helm.release.v1.<release>.v<revision> secrets.
#   - --failed-only: Ignore history limit; for each release, find revisions with
#                    status == "failed" and delete only those.
#
# Requirements:
#   - bash (3.x+)
#   - helm
#   - kubectl
#   - jq

set -u

CONFIRM="yes"                            # default behavior
SOURCE_FILE="helm-releases-summary.txt"  # default file
FAILED_ONLY="no"                         # default: process all using history limit

# ---------- Parse arguments ----------
for arg in "$@"; do
  case "$arg" in
    --file=*)
      SOURCE_FILE="${arg#*=}"
      ;;
    --confirm=*)
      CONFIRM="${arg#*=}"
      ;;
    --failed-only)
      FAILED_ONLY="yes"
      ;;
    -h|--help)
      echo "Usage: $0 [--file=FILE] [--confirm=yes|no] [--failed-only]"
      echo
      echo "  --file=FILE       Summary file generated by check-helm.sh"
      echo "                    (default: helm-releases-summary.txt)"
      echo "  --confirm=yes     Ask per release before deleting (default)"
      echo "  --confirm=no      Delete without per-release confirmation"
      echo "  --failed-only     Only delete revisions whose status is 'failed'."
      echo "                    (History limit is ignored in this mode.)"
      exit 0
      ;;
    *)
      echo "ERROR: Unknown argument: $arg" >&2
      echo "Use --help for usage." >&2
      exit 1
      ;;
  esac
done

if [[ ! -f "${SOURCE_FILE}" ]]; then
  echo "ERROR: File not found: ${SOURCE_FILE}" >&2
  echo "       Make sure you ran check-helm.sh first, or specify --file=..." >&2
  exit 1
fi

if [[ "${CONFIRM}" != "yes" && "${CONFIRM}" != "no" ]]; then
  echo "ERROR: --confirm must be 'yes' or 'no' (default is 'yes')." >&2
  exit 1
fi

# ---------- Verify file was generated by check-helm.sh ----------
if ! grep -q "Report generated through script - check-helm.sh" "${SOURCE_FILE}"; then
  echo "ERROR: Input file does NOT appear to be generated by check-helm.sh." >&2
  echo "       Missing marker line: 'Report generated through script - check-helm.sh'" >&2
  echo "       Aborting to avoid using manually prepared / incorrect input." >&2
  exit 1
fi

# ---------- Extract History limit from file (still needed for non-failed-only mode) ----------
HISTORY_LIMIT_LINE="$(grep -m1 '^History limit:' "${SOURCE_FILE}" || true)"

if [[ -z "${HISTORY_LIMIT_LINE}" ]]; then
  echo "ERROR: Could not find 'History limit: X' line in ${SOURCE_FILE}." >&2
  echo "       Ensure the file was generated by the latest check-helm.sh." >&2
  exit 1
fi

# Example line: "History limit: 3"
HISTORY_LIMIT_RAW="${HISTORY_LIMIT_LINE#History limit: }"
HISTORY_LIMIT_RAW="$(echo "${HISTORY_LIMIT_RAW}" | tr -d '[:space:]')"  # trim spaces

if ! [[ "${HISTORY_LIMIT_RAW}" =~ ^[0-9]+$ ]] || [ "${HISTORY_LIMIT_RAW}" -le 0 ]; then
  echo "ERROR: Parsed history limit is not a positive integer: '${HISTORY_LIMIT_RAW}'" >&2
  exit 1
fi

HISTORY_LIMIT="${HISTORY_LIMIT_RAW}"

# ---------- Tool checks ----------
if ! command -v helm >/dev/null 2>&1; then
  echo "ERROR: 'helm' command not found in PATH." >&2
  exit 1
fi

if ! command -v kubectl >/dev/null 2>&1; then
  echo "ERROR: 'kubectl' command not found in PATH." >&2
  exit 1
fi

if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: 'jq' command not found in PATH." >&2
  exit 1
fi

echo ">>> Using input file: ${SOURCE_FILE}"
echo ">>> CONFIRM       = ${CONFIRM} (yes = ask per release, no = non-interactive)"
echo ">>> HISTORY_LIMIT = ${HISTORY_LIMIT} (used only when --failed-only is not set)"
echo ">>> FAILED_ONLY   = ${FAILED_ONLY} (yes = delete only failed revisions)"
echo

FOUND_LINES=0

# Function to output summary lines as: namespace|release|revisions
summary_stream() {
  awk '
    /NAMESPACE[[:space:]]+RELEASE[[:space:]]+REVISIONS/ {start=1; getline; next}
    start==1 && NF>=3 && $1 != "NAMESPACE" && $1 !~ /^-+$/ {
      # $1 = namespace, $2 = release, $3 = revisions
      print $1 "|" $2 "|" $3
    }
  ' "$1"
}

# ---------- Main loop over summary rows ----------
while IFS='|' read -r NAMESPACE RELEASE_NAME REV_COUNT_REPORTED; do
  FOUND_LINES=1

  echo "============================================================"
  echo "Processing release '${RELEASE_NAME}' in namespace '${NAMESPACE}'"
  echo "Reported revisions (from check-helm.sh): ${REV_COUNT_REPORTED}"
  echo "History limit (to keep): ${HISTORY_LIMIT}"
  echo "============================================================"

  # Get current helm history in JSON
  HISTORY_JSON="$(helm history "${RELEASE_NAME}" -n "${NAMESPACE}" -o json 2>/dev/null || true)"

  if [[ -z "${HISTORY_JSON}" ]]; then
    echo "  [WARN] Unable to retrieve helm history for ${RELEASE_NAME} in ${NAMESPACE}."
    echo "         It may have been deleted or there was an error."
    echo
    continue
  fi

  # ---------- MODE 1: FAILED_ONLY = yes ----------
  if [[ "${FAILED_ONLY}" == "yes" ]]; then
    # Get revisions whose status is 'failed' (case-insensitive)
    FAILED_REVS="$(echo "${HISTORY_JSON}" \
      | jq -r '.[] | select((.status // "" | ascii_downcase) == "failed") | .revision' \
      | sort -n)"

    if [[ -z "${FAILED_REVS}" ]]; then
      echo "  Info: --failed-only set and no failed revisions found; skipping this release."
      echo
      continue
    fi

    echo "  Info: --failed-only set. Failed revision(s) for this release:"
    echo "    ${FAILED_REVS}"
    echo

    # Build list of secrets to be deleted (only failed revisions)
    SECRETS_LIST=""
    while read -r REV; do
      [[ -z "${REV}" ]] && continue
      SECRET_NAME="sh.helm.release.v1.${RELEASE_NAME}.v${REV}"
      SECRETS_LIST="${SECRETS_LIST}- ${SECRET_NAME}, namespace ${NAMESPACE}\n"
    done <<< "${FAILED_REVS}"

    if [[ -z "${SECRETS_LIST}" ]]; then
      echo "  [WARN] Computed no secrets to delete for this release (failed-only mode). Skipping."
      echo
      continue
    fi

    DO_DELETE="yes"

    if [[ "${CONFIRM}" == "yes" ]]; then
      echo "Secrets to be deleted for release '${RELEASE_NAME}' in namespace '${NAMESPACE}' (FAILED ONLY):"
      printf "%b" "${SECRETS_LIST}"
      echo

      # Ask user whether to proceed for this release, reading from the terminal, not stdin
      while true; do
        printf "Proceed to delete these failed revision secrets? [yes/no]: " > /dev/tty
        if ! read -r ANSWER < /dev/tty; then
          ANSWER=""
        fi

        case "${ANSWER}" in
          yes|y|Y)
            DO_DELETE="yes"
            break
            ;;
          no|n|N)
            DO_DELETE="no"
            break
            ;;
          *)
            echo "Please answer 'yes' or 'no'." >&2
            ;;
        esac
      done
    else
      echo "  Non-interactive mode (--confirm=no): will delete failed revision secrets without prompt."
      echo
    fi

    if [[ "${DO_DELETE}" != "yes" ]]; then
      echo "  Skipping deletion for release '${RELEASE_NAME}' in namespace '${NAMESPACE}'."
      echo
      continue
    fi

    # Perform deletions for failed revisions only
    while read -r REV; do
      [[ -z "${REV}" ]] && continue
      SECRET_NAME="sh.helm.release.v1.${RELEASE_NAME}.v${REV}"

      echo "  Deleting failed secret '${SECRET_NAME}' in namespace '${NAMESPACE}'..."
      if kubectl delete secret "${SECRET_NAME}" -n "${NAMESPACE}" --ignore-not-found; then
        echo "    OK: Deleted ${SECRET_NAME}"
      else
        echo "    ERROR: Failed to delete ${SECRET_NAME}" >&2
      fi
    done <<< "${FAILED_REVS}"

    echo
    # Skip the history-limit logic entirely in this mode
    continue
  fi

  # ---------- MODE 2: FAILED_ONLY = no (history limit trimming) ----------

  COUNT="$(echo "${HISTORY_JSON}" | jq 'length')"
  echo "  Actual current revision count: ${COUNT}"

  if [[ "${COUNT}" -le "${HISTORY_LIMIT}" ]]; then
    echo "  Info: Only ${COUNT} revision(s) present (<= ${HISTORY_LIMIT}). Nothing to delete."
    echo
    continue
  fi

  # Extract revision numbers and sort ascending
  ALL_REVS="$(echo "${HISTORY_JSON}" | jq '.[].revision' | sort -n)"
  NUM_TO_DELETE=$(( COUNT - HISTORY_LIMIT ))

  REVS_TO_DELETE_STR="$(echo "${ALL_REVS}" | head -n "${NUM_TO_DELETE}")"
  REVS_TO_KEEP_STR="$(echo "${ALL_REVS}" | tail -n "${HISTORY_LIMIT}")"

  echo "  Revisions to keep (latest ${HISTORY_LIMIT}):"
  echo "    ${REVS_TO_KEEP_STR}"
  echo "  Revisions to delete (oldest ${NUM_TO_DELETE}):"
  echo "    ${REVS_TO_DELETE_STR}"
  echo

  # Build list of secrets to be deleted (oldest revisions)
  SECRETS_LIST=""
  while read -r REV; do
    [[ -z "${REV}" ]] && continue
    SECRET_NAME="sh.helm.release.v1.${RELEASE_NAME}.v${REV}"
    SECRETS_LIST="${SECRETS_LIST}- ${SECRET_NAME}, namespace ${NAMESPACE}\n"
  done <<< "${REVS_TO_DELETE_STR}"

  if [[ -z "${SECRETS_LIST}" ]]; then
    echo "  [WARN] Computed no secrets to delete for this release. Skipping."
    echo
    continue
  fi

  DO_DELETE="yes"

  if [[ "${CONFIRM}" == "yes" ]]; then
    echo "Secrets to be deleted for release '${RELEASE_NAME}' in namespace '${NAMESPACE}':"
    printf "%b" "${SECRETS_LIST}"
    echo

    # Ask user whether to proceed for this release, reading from the terminal, not stdin
    while true; do
      printf "Proceed to delete these secrets? [yes/no]: " > /dev/tty
      if ! read -r ANSWER < /dev/tty; then
        ANSWER=""
      fi

      case "${ANSWER}" in
        yes|y|Y)
          DO_DELETE="yes"
          break
          ;;
        no|n|N)
          DO_DELETE="no"
          break
          ;;
        *)
          echo "Please answer 'yes' or 'no'." >&2
          ;;
      esac
    done
  else
    echo "  Non-interactive mode (--confirm=no): will delete secrets without prompt."
    echo
  fi

  if [[ "${DO_DELETE}" != "yes" ]]; then
    echo "  Skipping deletion for release '${RELEASE_NAME}' in namespace '${NAMESPACE}'."
    echo
    continue
  fi

  # Perform deletions (oldest revisions beyond history limit)
  while read -r REV; do
    [[ -z "${REV}" ]] && continue
    SECRET_NAME="sh.helm.release.v1.${RELEASE_NAME}.v${REV}"

    echo "  Deleting secret '${SECRET_NAME}' in namespace '${NAMESPACE}'..."
    if kubectl delete secret "${SECRET_NAME}" -n "${NAMESPACE}" --ignore-not-found; then
      echo "    OK: Deleted ${SECRET_NAME}"
    else
      echo "    ERROR: Failed to delete ${SECRET_NAME}" >&2
    fi
  done <<< "${REVS_TO_DELETE_STR}"

  echo

done < <(summary_stream "${SOURCE_FILE}")

if [[ "${FOUND_LINES}" -eq 0 ]]; then
  echo "No releases found in summary table (nothing to trim)."
fi

echo "All done."
